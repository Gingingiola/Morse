<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Codice Morse & ASCII</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: white; 
            color: #151228; /* Testo principale */
        }
        /* Custom scrollbar for textareas */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Colori dei bottoni personalizzati con CSS inline per maggiore precisione */

        /* Bottone Converti in Codice Morse */
        .btn-morse {
            background-color: #7f2426;
            color: white; /* Assicurati che il testo sia leggibile */
        }
        .btn-morse:hover {
            background-color: #6a1e20; /* Tonalità leggermente più scura per il hover */
        }

        /* Bottone Converti in Codice ASCII */
        .btn-ascii {
            background-color: #5f5730;
            color: white;
        }
        .btn-ascii:hover {
            background-color: #4b4425;
        }

        /* Bottone Converti da Morse a Testo */
        .btn-morse-to-text {
            background-color: #85736d;
            color: white;
        }
        .btn-morse-to-text:hover {
            background-color: #6e5f5a;
        }

        /* Bottone Converti da ASCII a Testo */
        .btn-ascii-to-text {
            background-color: #382c25;
            color: white;
        }
        .btn-ascii-to-text:hover {
            background-color: #2b221d;
        }

        /* Assicurati che anche i bordi e il testo siano coerenti */
        .text-gray-800 {
            color: #151228; /* Colore del testo principale */
        }
        .text-gray-700 {
            color: #2f2723; /* Un po' più chiaro del testo principale */
        }
        .border-gray-300 {
            border-color: #d1d5db; /* Colore predefinito di Tailwind per border-gray-300 */
        }
        .border-gray-200 {
            border-color: #e5e7eb; /* Colore predefinito di Tailwind per border-gray-200 */
        }

        /* Message box colors (mantenuti diversi per segnalare info/success/error) */
        .bg-blue-500 { background-color: #3b82f6; } /* Tailwind default */
        .bg-green-500 { background-color: #22c55e; } /* Tailwind default */
        .bg-red-500 { background-color: #ef4444; } /* Tailwind default */

        /* Pulsante "Copia nel Blocco Note" e i suoi hover (riportati ai valori Tailwind originali) */
        .bg-gray-200 { background-color: #e5e7eb; }
        .hover\:bg-gray-300:hover { background-color: #d1d5db; }

        /* Pulsanti audio (riportati ai valori Tailwind originali per red-600 e gray-500) */
        .bg-red-600 { background-color: #dc2626; }
        .hover\:bg-red-700:hover { background-color: #b91c1c; }
        .bg-gray-500 { background-color: #6b7280; }
        .hover\:bg-gray-600:hover { background-color: #4b5563; }

        /* NUOVI STILI PER GLI SLIDER */
        input[type="range"] {
            -webkit-appearance: none; /* Rimuove lo stile predefinito di WebKit */
            width: 100%;
            height: 8px; /* Altezza della barra */
            background: #e2e8f0; /* Colore della traccia di sfondo */
            border-radius: 5px;
            outline: none;
            cursor: pointer;
            transition: background 0.2s ease-in-out;
        }

        /* Stile del "thumb" (il pallino) per WebKit (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px; /* Dimensione del pallino */
            height: 20px; /* Dimensione del pallino */
            background: #151228; /* Colore del testo principale */
            border-radius: 50%; /* Rende il pallino circolare */
            border: none;
            cursor: pointer;
            margin-top: -6px; /* Centra il pallino sulla traccia */
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3); /* Piccola ombra sul pallino */
            transition: background 0.2s ease-in-out;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2f2723; /* Un po' più scuro all'hover */
        }

        /* Stile della "traccia riempita" (il colore a sinistra del pallino) per WebKit */
        input[type="range"]::-webkit-slider-runnable-track {
            background: linear-gradient(to right, #151228 var(--track-fill-percent, 0%), #e2e8f0 var(--track-fill-percent, 0%));
            height: 8px;
            border-radius: 5px;
        }

        /* Stile del "thumb" (il pallino) per Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #151228; /* Colore del testo principale */
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease-in-out;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #2f2723; /* Un po' più scuro all'hover */
        }

        /* Stile della "traccia" per Firefox */
        input[type="range"]::-moz-range-track {
            background: #e2e8f0; /* Colore della traccia di sfondo */
            height: 8px;
            border-radius: 5px;
        }

        /* Stile della "traccia riempita" per Firefox (simulazione) */
        /* Questo è più difficile in Firefox, richiede JavaScript per un riempimento accurato
           o un hack con `background: linear-gradient` sul track generale e l'impostazione di `--track-fill-percent` via JS. */
        input[type="range"]::-moz-range-progress {
            background-color: #151228; /* Colore di riempimento per la parte a sinistra del thumb */
            height: 8px;
            border-radius: 5px;
        }

        /* Stile del "thumb" (il pallino) per Edge/IE */
        input[type="range"]::-ms-thumb {
            width: 20px;
            height: 20px;
            background: #151228; /* Colore del testo principale */
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease-in-out;
        }

        input[type="range"]::-ms-thumb:hover {
            background: #2f2723; /* Un po' più scuro all'hover */
        }

        /* Stile della "traccia" per Edge/IE */
        input[type="range"]::-ms-track {
            width: 100%;
            height: 8px;
            background: transparent; /* Nasconde la traccia predefinita */
            border-color: transparent;
            color: transparent;
        }

        /* Stile della "traccia riempita" per Edge/IE */
        input[type="range"]::-ms-fill-lower {
            background: #151228; /* Colore di riempimento per la parte a sinistra del thumb */
            border-radius: 5px;
        }
        input[type="range"]::-ms-fill-upper {
            background: #e2e8f0; /* Colore della parte a destra del thumb */
            border-radius: 5px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-4xl space-y-8">
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-6">Laboratorio Interattivo Codice Morse & ASCII</h1>

        <div class="space-y-4">
            <label for="inputText" class="block text-lg font-semibold text-gray-700">Scrivi il tuo testo qui:</label>
            <textarea id="inputText" rows="6" class="w-full p-4 border-2 border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-gray-800 text-base resize-y shadow-sm" placeholder="Inserisci il testo da convertire..."></textarea>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <button id="convertToMorse" class="btn-morse font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105">
                Converti in Codice Morse
            </button>
            <button id="convertToAscii" class="btn-ascii font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105">
                Converti in Codice ASCII
            </button>
            <button id="convertMorseToText" class="btn-morse-to-text font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105">
                Converti da Morse a Testo
            </button>
            <button id="convertAsciiToText" class="btn-ascii-to-text font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105">
                Converti da ASCII a Testo
            </button>
        </div>

        <div class="space-y-4">
            <label for="outputText" class="block text-lg font-semibold text-gray-700">Risultato della Conversione:</label>
            <textarea id="outputText" rows="6" class="w-full p-4 border-2 border-gray-300 rounded-lg bg-gray-50 text-gray-800 text-base resize-y shadow-sm" readonly placeholder="Il risultato apparirà qui..."></textarea>
            <button id="copyToClipboard" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-sm transition duration-300 ease-in-out">
                Copia nel Blocco Note
            </button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="bg-gray-50 p-6 rounded-xl shadow-inner space-y-4">
                <h2 class="text-2xl font-bold text-gray-800">Conversione Passo-Passo:</h2>
                <div id="stepByStepOutput" class="bg-white p-4 rounded-lg border border-gray-200 min-h-[150px] overflow-y-auto text-gray-700 text-sm">
                    <p>I dettagli della conversione appariranno qui.</p>
                </div>
            </div>

            <div class="bg-gray-50 p-6 rounded-xl shadow-inner space-y-4">
                <h2 class="text-2xl font-bold text-gray-800">Riproduci Codice Morse:</h2>
                <div class="flex items-center space-x-4">
                    <button id="playMorse" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-5 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105">
                        Riproduci Audio
                    </button>
                    <button id="stopMorse" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-5 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:-translate-y-1 hover:scale-105" disabled>
                        Stop Audio
                    </button>
                </div>
                <div class="space-y-2">
                    <label for="volumeControl" class="block text-gray-700">Volume:</label>
                    <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                <div class="space-y-2">
                    <label for="speedControl" class="block text-gray-700">Velocità (ms per punto):</label>
                    <input type="range" id="speedControl" min="50" max="500" step="10" value="150" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="speedValue" class="text-sm text-gray-600">150 ms</span>
                </div>
            </div>
        </div>

        <div id="messageBox" class="fixed bottom-4 right-4 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hidden z-50 transition-all duration-300 ease-in-out transform translate-y-full opacity-0">
            Messaggio di esempio
        </div>

    </div>

    <script>
        // Mappa del codice Morse (maiuscole, numeri, punteggiatura comune)
        const morseCodeMap = {
            'A': '•– ', 'B': ' –•••', 'C': ' –•–•', 'D': ' –••', 'E': '•', 'F': '••–•', 'G': ' – –•', 'H': '••••',
            'I': '••', 'J': '•– – – ', 'K': ' –•– ', 'L': '•–••', 'M': ' – – ', 'N': ' –•', 'O': ' – – – ', 'P': '•– –•',
            'Q': ' – –•–', 'R': '•–•', 'S': '•••', 'T': ' – ', 'U': '••– ', 'V': '•••– ', 'W': '•– – ', 'X': ' –••– ',
            'Y': '–•– – ', 'Z': ' – –••',
            '0': ' – – – – – ', '1': '•– – – – ', '2': '••– – – ', '3': '•••– – ', '4': '••••– ', '5': '•••••',
            '6': ' –••••', '7': ' – –•••', '8': ' – – –••', '9': ' – – – –•',
            '.': '•–•–•– ', ',': ' – –••– – ', '?': '••– –••', "'": '•– – – –•', '!': ' –•–•– – ', '/': ' –••–•',
            '(': ' –•– –•', ')': ' –•––•– ', '&': '•–•••', ':': ' – – –•••', ';': ' –•–•–•', '=': ' –•••– ',
            '+': '•–•–•', '-': ' –••••– ', '_': '••– –•– ', '"': '•–••–•', '$': '•••–••– ', '@': '•– –•–•',
            ' ': ' ' // Spazio tra le parole
        };

        // Inverti la mappa per la conversione da Morse a testo
        const reverseMorseCodeMap = Object.entries(morseCodeMap).reduce((acc, [key, value]) => {
            acc[value] = key;
            return acc;
        }, {});

        // Elementi DOM
        const inputText = document.getElementById('inputText');
        const outputText = document.getElementById('outputText');
        const convertToMorseBtn = document.getElementById('convertToMorse');
        const convertToAsciiBtn = document.getElementById('convertToAscii');
        const convertMorseToTextBtn = document.getElementById('convertMorseToText');
        const convertAsciiToTextBtn = document.getElementById('convertAsciiToText');
        const copyToClipboardBtn = document.getElementById('copyToClipboard');
        const stepByStepOutput = document.getElementById('stepByStepOutput');
        const playMorseBtn = document.getElementById('playMorse');
        const stopMorseBtn = document.getElementById('stopMorse');
        const volumeControl = document.getElementById('volumeControl');
        const speedControl = document.getElementById('speedControl');
        const speedValueSpan = document.getElementById('speedValue');
        const messageBox = document.getElementById('messageBox');

        let audioContext;
        let oscillator;
        let gainNode;
        let isPlaying = false;
        let currentTimeout; // Per tenere traccia del timeout della riproduzione del tono

        // Funzione per mostrare messaggi all'utente
        function showMessage(message, type = 'info', duration = 3000) {
            messageBox.textContent = message;
            messageBox.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300 ease-in-out transform opacity-100`;
            if (type === 'success') {
                messageBox.classList.add('bg-green-500');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-500');
            } else {
                messageBox.classList.add('bg-blue-500');
            }
            messageBox.classList.remove('translate-y-full', 'hidden');

            setTimeout(() => {
                messageBox.classList.add('translate-y-full', 'opacity-0');
                messageBox.addEventListener('transitionend', function handler() {
                    messageBox.classList.add('hidden');
                    messageBox.removeEventListener('transitionend', handler);
                });
            }, duration);
        }

        // Funzioni di Conversione
        // Testo a Codice Morse
        function textToMorse(text) {
            let morse = '';
            let stepByStepHtml = '';
            const normalizedText = text.toUpperCase(); // Converti tutto in maiuscolo per la mappatura

            for (let i = 0; i < normalizedText.length; i++) {
                const char = normalizedText[i];
                const morseChar = morseCodeMap[char];

                if (morseChar !== undefined) {
                    morse += morseChar + ' '; // Aggiungi spazio tra i caratteri Morse
                    stepByStepHtml += `<p><span class="font-bold">${char}</span>: ${morseChar}</p>`;
                } else {
                    // Gestisci caratteri non mappati
                    morse += '#ERROR# '; // Segnala un carattere non riconosciuto
                    stepByStepHtml += `<p><span class="font-bold text-red-500">${char}</span>: Carattere non supportato</p>`;
                }
            }
            stepByStepOutput.innerHTML = stepByStepHtml || '<p>I dettagli della conversione appariranno qui.</p>';
            return morse.trim(); // Rimuovi lo spazio finale
        }

        // Codice Morse a Testo
        function morseToText(morse) {
            let text = '';
            let stepByStepHtml = '';
            // Dividi il codice Morse in singoli "caratteri" Morse, gestendo gli spazi tra le parole
            const morseChars = morse.split(' ').filter(c => c !== ''); // Filtra spazi vuoti extra

            for (let i = 0; i < morseChars.length; i++) {
                const morseChar = morseChars[i];
                if (morseChar === '') { // Questo caso dovrebbe essere gestito dal filter, ma per sicurezza
                    text += ' ';
                    stepByStepHtml += `<p><span class="font-bold">[Spazio]</span>: (Separatore di parole)</p>`;
                } else {
                    const char = reverseMorseCodeMap[morseChar];
                    if (char !== undefined) {
                        text += char;
                        stepByStepHtml += `<p><span class="font-bold">${morseChar}</span>: ${char}</p>`;
                    } else {
                        text += '[?]'; // Segnala un codice Morse non riconosciuto
                        stepByStepHtml += `<p><span class="font-bold text-red-500">${morseChar}</span>: Codice Morse non riconosciuto</p>`;
                    }
                }
            }
            stepByStepOutput.innerHTML = stepByStepHtml || '<p>I dettagli della conversione appariranno qui.</p>';
            return text;
        }

        // Testo a Codice ASCII (Decimal, Binary, Hex)
        function textToAscii(text) {
            let asciiOutput = '';
            let stepByStepHtml = '';

            for (let i = 0; i < text.length; i++) {
                const char = text.charAt(i);
                const charCode = char.charCodeAt(0);

                // Mostra i valori in Decimale, Binario e Esadecimale con i prefissi
                // Aggiungiamo uno spazio finale per facilitare lo split di asciiToText
                asciiOutput += `Dec: ${charCode} Bin: ${charCode.toString(2).padStart(8, '0')} Hex: ${charCode.toString(16).toUpperCase()} `;
                stepByStepHtml += `<p><span class="font-bold">'${char}'</span>: Dec: ${charCode}, Bin: ${charCode.toString(2).padStart(8, '0')}, Hex: ${charCode.toString(16).toUpperCase()}</p>`;
            }
            stepByStepOutput.innerHTML = stepByStepHtml || '<p>I dettagli della conversione appariranno qui.</p>';
            return asciiOutput.trim();
        }

        // Codice ASCII a Testo (gestisce valori decimali, binari o esadecimali, inclusi quelli formattati)
        function asciiToText(asciiInput) {
            let text = '';
            let stepByStepHtml = '';

            // Rimuovi esplicitamente tutti i caratteri di controllo (ASCII 0-31) e poi rimuovi spazi extra
            const cleanedInput = asciiInput
                .replace(/[\u0000-\u001F\u007F-\u009F]/g, ' ') // Rimuovi caratteri di controllo ASCII 0-31 e 127-159 (per sicurezza)
                .replace(/\s+/g, ' ') // Riduci spazi multipli a singolo spazio
                .trim(); // Rimuovi spazi all'inizio e alla fine

            console.log("cleanedInput dopo pulizia aggressiva:", JSON.stringify(cleanedInput));

            // Questa regex è molto più specifica e cerca solo i pattern numerici con o senza prefisso
            const regex = /(Dec:\s*\d+)|(Bin:\s*[01]+)|(Hex:\s*[0-9a-fA-F]+)|(0x[0-9a-fA-F]+)|(0b[01]+)|([0-9a-fA-F]+)/gi;
            let match;
            const extractedValues = [];

            while ((match = regex.exec(cleanedInput)) !== null) {
                // Il match conterrà i gruppi di cattura, solo uno sarà non-null per ogni match
                let value = null;
                let type = 'auto'; // Default type, se non specificato dal prefisso

                if (match[1]) { // Dec:
                    value = match[1].substring(4).trim(); // Rimuovi 'Dec:' e spazi
                    type = 'dec';
                } else if (match[2]) { // Bin:
                    value = match[2].substring(4).trim(); // Rimuovi 'Bin:' e spazi
                    type = 'bin';
                } else if (match[3]) { // Hex:
                    value = match[3].substring(4).trim(); // Rimuovi 'Hex:' e spazi
                    type = 'hex';
                } else if (match[4]) { // 0x
                    value = match[4].substring(2).trim(); // Rimuovi '0x'
                    type = 'hex';
                } else if (match[5]) { // 0b
                    value = match[5].substring(2).trim(); // Rimuovi '0b'
                    type = 'bin';
                } else if (match[6]) { // Numero puro
                    value = match[6].trim();
                    type = 'auto'; // Sarà determinato in base al contenuto
                }

                if (value) {
                    extractedValues.push({ value, type });
                }
            }

            console.log("Valori Estratti (strutturati):", JSON.stringify(extractedValues));

            if (extractedValues.length === 0) {
                stepByStepOutput.innerHTML = '<p class="text-red-500">Nessun valore ASCII valido trovato. Inserisci numeri decimali, binari o esadecimali.</p>';
                return '';
            }

            for (const item of extractedValues) {
                const tokenValue = item.value;
                const tokenType = item.type; // Tipo suggerito dal prefisso o 'auto'
                let charCode;
                let parsedAsType = 'Sconosciuto'; // Il tipo effettivo dopo il parsing

                if (tokenType === 'dec') {
                    charCode = parseInt(tokenValue, 10);
                    parsedAsType = 'Decimale (da prefisso)';
                } else if (tokenType === 'bin') {
                    // Controlla che sia un binario valido prima di parsare
                    if (/^[01]+$/.test(tokenValue)) {
                        charCode = parseInt(tokenValue, 2);
                        parsedAsType = 'Binario (da prefisso)';
                    } else {
                        charCode = NaN; // Non è un binario valido
                    }
                } else if (tokenType === 'hex') {
                    // Controlla che sia un esadecimale valido
                    if (/^[0-9a-fA-F]+$/.test(tokenValue)) {
                        charCode = parseInt(tokenValue, 16);
                        parsedAsType = 'Esadecimale (da prefisso)';
                    } else {
                        charCode = NaN; // Non è un esadecimale valido
                    }
                }
                // Logica per i token di tipo 'auto' (senza prefisso)
                else if (tokenType === 'auto') {
                    // Ordine di precedenza per i numeri puri: Binario > Esadecimale > Decimale
                    // 1. Binario puro (solo 0/1, lunghezza tra 1 e 8 per evitare di confondere con decimali)
                    if (/^[01]{1,8}$/.test(tokenValue) && (tokenValue.length > 1 || tokenValue === '0' || tokenValue === '1')) { // 1 o più cifre binarie
                        // Per es. "101" dovrebbe essere binario (5) non decimale (101)
                        charCode = parseInt(tokenValue, 2);
                        parsedAsType = 'Binario (puro)';
                    }
                    // 2. Esadecimale puro (contiene a-f o è un esadecimale valido a 1-2 cifre senza prefisso)
                    // Questa è la condizione più delicata, per non confondere con i decimali
                    else if (/^[0-9a-fA-F]+$/.test(tokenValue) && (/[a-fA-F]/.test(tokenValue) || tokenValue.length <= 2)) {
                        // Se ha lettere (es. "AB"), è sicuramente hex.
                        // Se è solo cifre ma è breve (es. "41"), consideralo hex se non è un binario puro.
                        // La lunghezza <= 2 è euristica per i char ASCII.
                        charCode = parseInt(tokenValue, 16);
                        parsedAsType = 'Esadecimale (puro)';
                    }
                    // 3. Decimale puro (ultima spiaggia, solo cifre)
                    else if (/^\d+$/.test(tokenValue)) {
                        charCode = parseInt(tokenValue, 10);
                        parsedAsType = 'Decimale (puro)';
                    }
                    else {
                        charCode = NaN; // Non è un formato numerico riconosciuto
                        parsedAsType = 'Non riconosciuto';
                    }
                }

                if (!isNaN(charCode) && charCode >= 0 && charCode <= 255) { // Range ASCII valido
                    const char = String.fromCharCode(charCode);
                    text += char;
                    stepByStepHtml += `<p><span class="font-bold">${tokenValue}</span> (Parsed as ${parsedAsType}): '${char}' (Dec: ${charCode}, Bin: ${charCode.toString(2).padStart(8, '0')}, Hex: ${charCode.toString(16).toUpperCase()})</p>`;
                } else {
                    text += '[?]'; // Carattere non riconosciuto o fuori range
                    stepByStepHtml += `<p><span class="font-bold text-red-500">${tokenValue}</span>: Valore "${tokenValue}" non valido o fuori intervallo ASCII</p>`;
                }
            }
            stepByStepOutput.innerHTML = stepByStepHtml || '<p>I dettagli della conversione appariranno qui.</p>';
            return text;
        }

        // Gestione Audio Morse
        function initAudioContext() {
            if (!audioContext) {
                // Crea AudioContext solo se non esiste
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = volumeControl.value; // Imposta il volume iniziale
                console.log('AudioContext e GainNode inizializzati.');
            }

            // Aggiungi un listener per riprendere l'audio context se è sospeso
            // Questo è necessario per molti browser che richiedono un'interazione utente
            // per avviare l'audio.
            if (audioContext.state === 'suspended') {
                // Tentativo di riprendere l'audio context solo una volta
                audioContext.resume().then(() => {
                    console.log('AudioContext ripreso con successo.');
                }).catch(e => console.error('Errore nel riprendere AudioContext:', e));
            }
        }

        function playTone(duration, frequency = 600) {
            return new Promise(resolve => {
                if (!audioContext || !isPlaying) {
                    console.log('playTone: AudioContext non pronto o riproduzione interrotta.');
                    resolve();
                    return;
                }

                // Ferma e disconnetti l'oscillatore precedente se esiste
                if (oscillator) {
                    try {
                        oscillator.stop(0);
                        oscillator.disconnect();
                        oscillator = null;
                        console.log('Oscillatore precedente fermato e disconnesso.');
                    } catch (e) {
                        console.error('Errore nel disconnettere l\'oscillatore precedente:', e);
                    }
                }

                oscillator = audioContext.createOscillator();
                oscillator.type = 'sine'; // Sine wave for a clear tone
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.connect(gainNode);

                oscillator.start(audioContext.currentTime);
                console.log(`Riproduco tono per ${duration}ms alla frequenza ${frequency}Hz.`);

                currentTimeout = setTimeout(() => {
                    if (oscillator) { // Assicurati che l'oscillatore esista ancora
                        oscillator.stop(audioContext.currentTime);
                        oscillator.disconnect();
                        oscillator = null; // Rimuovi il riferimento all'oscillatore
                        console.log('Tono fermato.');
                    }
                    resolve();
                }, duration);
            });
        }

        async function playMorseCode(morseString) {
            // Inizializza l'AudioContext al click del pulsante play
            initAudioContext();
            if (!audioContext) {
                showMessage('Impossibile inizializzare l\'audio. Controlla le impostazioni del browser.', 'error');
                return;
            }

            isPlaying = true;
            playMorseBtn.disabled = true;
            stopMorseBtn.disabled = false;
            console.log('Avvio riproduzione Morse. isPlaying:', isPlaying);

            const dotDuration = parseInt(speedControl.value); // Durata di un "punto" in ms
            const dashDuration = dotDuration * 3; // Durata di una "linea"
            const charSpaceDuration = dotDuration; // Spazio tra i simboli all'interno di una lettera
            const letterSpaceDuration = dotDuration * 3; // Spazio tra le lettere
            const wordSpaceDuration = dotDuration * 7; // Spazio tra le parole

            const morseSequence = morseString.split(' '); // Divide in lettere/parole

            try {
                for (let i = 0; i < morseSequence.length; i++) {
                    if (!isPlaying) {
                        console.log('Riproduzione interrotta dall\'utente.');
                        break;
                    }
                    const char = morseSequence[i];

                    if (char === '') { // Gestisce spazi extra che genererebbero token vuoti
                        console.log('Pausa tra parole (spazio extra):', wordSpaceDuration, 'ms');
                        await new Promise(resolve => setTimeout(resolve, wordSpaceDuration));
                    } else {
                        for (let j = 0; j < char.length; j++) {
                            if (!isPlaying) {
                                console.log('Riproduzione interrotta dall\'utente.');
                                break;
                            }
                            const symbol = char[j];
                            if (symbol === '•') {
                                await playTone(dotDuration);
                            } else if (symbol === '–') {
                                await playTone(dashDuration);
                            }
                            // Spazio tra i simboli all'interno di una lettera
                            if (j < char.length - 1 && isPlaying) { // Aggiungi isPlaying qui per fermare immediatamente
                                await new Promise(resolve => {
                                    currentTimeout = setTimeout(resolve, charSpaceDuration);
                                });
                            }
                        }
                        // Spazio tra le lettere
                        if (i < morseSequence.length - 1 && isPlaying) { // Aggiungi isPlaying qui per fermare immediatamente
                            await new Promise(resolve => {
                                currentTimeout = setTimeout(resolve, letterSpaceDuration);
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Errore durante la riproduzione del codice Morse:', error);
                showMessage('Errore durante la riproduzione audio: ' + error.message, 'error');
            } finally {
                isPlaying = false;
                playMorseBtn.disabled = false;
                stopMorseBtn.disabled = true;
                if (oscillator) {
                    try {
                        oscillator.stop(0);
                        oscillator.disconnect();
                        oscillator = null;
                    } catch (e) {
                        console.error('Errore finale nello stop dell\'oscillatore:', e);
                    }
                }
                if (currentTimeout) {
                    clearTimeout(currentTimeout);
                    currentTimeout = null;
                }
                console.log('Riproduzione Morse terminata. isPlaying:', isPlaying);
            }
        }

        function stopMorsePlayback() {
            console.log('Tentativo di stop riproduzione Morse.');
            isPlaying = false;
            if (oscillator) {
                try {
                    oscillator.stop(0); // Stop immediately
                    oscillator.disconnect();
                    console.log('Oscillatore fermato e disconnesso.');
                } catch (e) {
                    console.error('Errore nello stop dell\'oscillatore:', e);
                }
                oscillator = null;
            }
            if (currentTimeout) {
                clearTimeout(currentTimeout);
                currentTimeout = null;
                console.log('Timeout per la riproduzione cancellato.');
            }
            playMorseBtn.disabled = false;
            stopMorseBtn.disabled = true;
            showMessage('Riproduzione Morse interrotta.', 'info');
        }

        // Listeners degli Eventi
        convertToMorseBtn.addEventListener('click', () => {
            const text = inputText.value;
            if (text.trim() === '') {
                showMessage('Per favore, inserisci del testo da convertire in Morse.', 'error');
                return;
            }
            const morse = textToMorse(text);
            outputText.value = morse;
            showMessage('Testo convertito in Codice Morse!', 'success');
        });

        convertToAsciiBtn.addEventListener('click', () => {
            const text = inputText.value;
            if (text.trim() === '') {
                showMessage('Per favor, inserisci del testo da convertire in ASCII.', 'error');
                return;
            }
            const ascii = textToAscii(text);
            outputText.value = ascii;
            showMessage('Testo convertito in Codice ASCII!', 'success');
        });

        convertMorseToTextBtn.addEventListener('click', () => {
            const morse = inputText.value;
            if (morse.trim() === '') {
                showMessage('Per favore, inserisci del Codice Morse da convertire in testo.', 'error');
                return;
            }
            // Aggiungi una validazione per i nuovi simboli nel morseToText
            if (!morse.match(/^[•– ]+$/)) {
                showMessage('L\'input Morse deve contenere solo "•", "–" e spazi.', 'error');
                return;
            }
            const text = morseToText(morse);
            outputText.value = text;
            showMessage('Codice Morse convertito in testo!', 'success');
        });

        convertAsciiToTextBtn.addEventListener('click', () => {
            const ascii = inputText.value;
            if (ascii.trim() === '') {
                showMessage('Per favore, inserisci del Codice ASCII da convertire in testo.', 'error');
                return;
            }
            const text = asciiToText(ascii);
            outputText.value = text;
            showMessage('Codice ASCII convertito in testo!', 'success');
        });

        copyToClipboardBtn.addEventListener('click', () => {
            const textToCopy = outputText.value;
            if (textToCopy.trim() === '') {
                showMessage('Nessun testo da copiare.', 'error');
                return;
            }
            // Usa l'API Clipboard moderna se disponibile, altrimenti fallback
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => showMessage('Testo copiato nel blocco note!', 'success'))
                    .catch(err => {
                        console.error('Errore durante la copia con Clipboard API:', err);
                        fallbackCopyTextToClipboard(textToCopy);
                    });
            } else {
                fallbackCopyTextToClipboard(textToCopy);
            }
        });

        function fallbackCopyTextToClipboard(textToCopy) {
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = textToCopy;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('Testo copiato nel blocco note (fallback)!', 'success');
                } else {
                    showMessage('Impossibile copiare il testo (fallback).', 'error');
                }
            } catch (err) {
                showMessage('Errore durante la copia (fallback): ' + err, 'error');
            }
            document.body.removeChild(tempTextArea);
        }

        playMorseBtn.addEventListener('click', () => {
            const morseToPlay = outputText.value;
            // Aggiorna la regex per i nuovi simboli
            if (morseToPlay.trim() === '' || !morseToPlay.match(/^[•– ]+$/)) {
                showMessage('Per favor, converti prima il testo in Codice Morse (con "•" e "–") per riprodurre l\'audio.', 'error');
                return;
            }
            playMorseCode(morseToPlay);
            showMessage('Riproduzione Codice Morse avviata...', 'info');
        });

        stopMorseBtn.addEventListener('click', stopMorsePlayback);

        volumeControl.addEventListener('input', () => {
            if (gainNode) {
                gainNode.gain.value = parseFloat(volumeControl.value); // Assicurati che sia un float
            }
            // Aggiorna la traccia riempita per WebKit
            const percent = (volumeControl.value - volumeControl.min) / (volumeControl.max - volumeControl.min) * 100;
            volumeControl.style.setProperty('--track-fill-percent', `${percent}%`);
        });

        speedControl.addEventListener('input', () => {
            speedValueSpan.textContent = `${speedControl.value} ms`;
            // Aggiorna la traccia riempita per WebKit
            const percent = (speedControl.value - speedControl.min) / (speedControl.max - speedControl.min) * 100;
            speedControl.style.setProperty('--track-fill-percent', `${percent}%`);
        });

        // Inizializza il valore della velocità
        speedValueSpan.textContent = `${speedControl.value} ms`;

        // Inizializza la traccia riempita al caricamento della pagina per entrambi gli slider
        volumeControl.dispatchEvent(new Event('input'));
        speedControl.dispatchEvent(new Event('input'));

    </script>
</body>
</html>