<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Animation with p5.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0; /* Light gray background for the page */
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #ccc; /* Add a border to the canvas for better visibility */
            box-shadow: 2px 2px 8px rgba(0,0,0,0.2); /* Optional: add a subtle shadow */
        }
        h1 {
            position: absolute;
            top: 20px;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>Interactive Circuit</h1>

    <script>
        // Costante per il fattore di scala globale
        const GLOBAL_SCALE_FACTOR = 2; // Raddoppia la dimensione

        // Colori principali del circuito
        let YELLOW_LIGHT;
        let WHITE_COMPONENT;
        let GREEN_CIRCUIT;
        let DARK_BLUE_KNOB;
        let GREEN_STROKE;
        let MEDIUM_BLUE_KNOB;

        // Opacità per le lampadine
        const LIGHTBULB_ALPHA_OFF = 76; // Opacità lampadina spenta (0.3 * 255)
        const LIGHTBULB_ALPHA_ON = 255; // Opacità lampadina accesa (1.0 * 255)

        // Variabili per lo stato dell'animazione del terminale DESTRO
        let isRightCircuitOn = false; // Stato: true = acceso, false = spento (terminale destro)
        let rightTerminalRotationAngle = 0;
        let rightTerminalTargetAngle = 0;
        const RIGHT_TERMINAL_OFF_ANGLE = -31; // Angolo "aperto" per il terminale destro
        const RIGHT_TERMINAL_ON_ANGLE = -8; // Angolo "chiuso" per il terminale destro (calibrato per toccare)

        // Variabili per lo stato dell'animazione del terminale SINISTRO
        let isLeftCircuitOn = false; // Stato: true = acceso, false = spento (terminale sinistro)
        let leftTerminalRotationAngle = 0;
        let leftTerminalTargetAngle = 0;
        const LEFT_TERMINAL_OFF_ANGLE = -34; // Angolo "aperto" per il terminale sinistro
        const LEFT_TERMINAL_ON_ANGLE = -8; // Angolo "chiuso" per il terminale sinistro (calibrato per toccare)

        const TERMINAL_ROTATION_SPEED = 0.1; // Velocità di interpolazione per la rotazione (0.0-1.0)

        // Dettagli del terminale destro per il calcolo della rotazione
        const TERMINAL_RIGHT_RECT_WIDTH = 35;
        const TERMINAL_RIGHT_RECT_HEIGHT = 3;
        const TERMINAL_RIGHT_PIVOT_X = 325;
        const TERMINAL_RIGHT_PIVOT_Y = 20;

        // Dettagli del terminale sinistro per il calcolo della rotazione
        const TERMINAL_LEFT_RECT_WIDTH = 35;
        const TERMINAL_LEFT_RECT_HEIGHT = 3;
        const TERMINAL_LEFT_PIVOT_X = 109;
        const TERMINAL_LEFT_PIVOT_Y = 20;

        function setup() {
          createCanvas(400 * GLOBAL_SCALE_FACTOR, 150 * GLOBAL_SCALE_FACTOR);

          YELLOW_LIGHT = color(251, 193, 33);
          WHITE_COMPONENT = color(255);
          GREEN_CIRCUIT = color(0, 152, 58);
          DARK_BLUE_KNOB = color(61, 90, 132);
          GREEN_STROKE = color(0, 152, 58);
          MEDIUM_BLUE_KNOB = color(84, 111, 154);

          // Inizializza angoli terminale destro
          rightTerminalRotationAngle = RIGHT_TERMINAL_OFF_ANGLE;
          rightTerminalTargetAngle = RIGHT_TERMINAL_OFF_ANGLE;

          // Inizializza angoli terminale sinistro
          leftTerminalRotationAngle = LEFT_TERMINAL_OFF_ANGLE;
          leftTerminalTargetAngle = LEFT_TERMINAL_OFF_ANGLE;
        }

        function draw() {
          background(255);

          scale(GLOBAL_SCALE_FACTOR);

          // Aggiorna l'angolo di rotazione del terminale destro
          if (abs(rightTerminalRotationAngle - rightTerminalTargetAngle) > 0.01) {
            rightTerminalRotationAngle = lerp(rightTerminalRotationAngle, rightTerminalTargetAngle, TERMINAL_ROTATION_SPEED);
          }
          // Aggiorna l'angolo di rotazione del terminale sinistro
          if (abs(leftTerminalRotationAngle - leftTerminalTargetAngle) > 0.01) {
            leftTerminalRotationAngle = lerp(leftTerminalRotationAngle, leftTerminalTargetAngle, TERMINAL_ROTATION_SPEED);
          }

          // Definisci i colori attivi per i rami specifici
          let activeColorForRightBranches = GREEN_STROKE;
          let activeColorForLeftBranches = GREEN_STROKE;

          if (isRightCircuitOn && isLeftCircuitOn) {
              activeColorForRightBranches = color(255, 0, 0); // Rosso se entrambi ON
              activeColorForLeftBranches = color(255, 0, 0);   // Rosso se entrambi ON
          } else if (isRightCircuitOn) {
              activeColorForRightBranches = color(255, 0, 0); // Rosso solo il lato destro
          } else if (isLeftCircuitOn) {
              activeColorForLeftBranches = color(255, 0, 0);   // Rosso solo il lato sinistro
          }
          // Se nessuno è ON, rimangono verdi di default.


          // NUOVA LOGICA PER IL RAMO 1 (linea orizzontale centrale): Rosso SOLO se uno dei due è ON
          let commonActiveColor;
          if ((isRightCircuitOn && !isLeftCircuitOn) || (!isRightCircuitOn && isLeftCircuitOn)) {
              commonActiveColor = color(255, 0, 0); // Rosso solo se uno è ON (XOR)
          } else {
              commonActiveColor = GREEN_STROKE; // Verde se entrambi ON o entrambi OFF
          }


          // --- Disegno degli elementi del circuito: ordine e posizione ---

          // I rami controllati dallo stato del terminale DESTRO
          drawMainCircuitLines_RightControlled(activeColorForRightBranches);
          // I rami controllati dallo stato del terminale SINISTRO
          drawMainCircuitLines_LeftControlled(activeColorForLeftBranches);
          // Il ramo comune (Ramo 1)
          drawMainCircuitLines_Common(commonActiveColor);


          drawRightBlock(300, 40);
          drawLeftBlock(84, 40);

          drawRightDial(232, 67);
          drawLeftDial(18, 71);

          // Lampadina destra controllata dal terminale SINISTRO
          let rightLightbulbAlpha = isLeftCircuitOn ? LIGHTBULB_ALPHA_ON : LIGHTBULB_ALPHA_OFF;
          drawRightLightbulb(243, 35, rightLightbulbAlpha);

          // Lampadina sinistra controllata dal terminale DESTRO
          let leftLightbulbAlpha = isRightCircuitOn ? LIGHTBULB_ALPHA_ON : LIGHTBULB_ALPHA_OFF;
          drawLeftLightbulb(36, 35, leftLightbulbAlpha);

          // Terminali e cerchi superiori (passiamo gli angoli e i colori appropriati)
          drawTerminalsAndTopGreenElements(rightTerminalRotationAngle, activeColorForRightBranches, // Colore per terminale destro e cerchi
                                           leftTerminalRotationAngle, activeColorForLeftBranches);  // Colore per terminale sinistro e cerchi
        }

        function mousePressed() {
          let mouseXScaled = mouseX / GLOBAL_SCALE_FACTOR;
          let mouseYScaled = mouseY / GLOBAL_SCALE_FACTOR;

          // Area cliccabile per il terminale DESTRO
          // Considera il pivot e aggiungi un margine per una migliore interazione
          const clickableRightTerminalX = TERMINAL_RIGHT_PIVOT_X - TERMINAL_RIGHT_RECT_WIDTH;
          const clickableRightTerminalY = TERMINAL_RIGHT_PIVOT_Y - (TERMINAL_RIGHT_RECT_HEIGHT / 2) - 10;
          const clickableRightTerminalWidth = TERMINAL_RIGHT_RECT_WIDTH + 15; // Aumento larghezza
          const clickableRightTerminalHeight = TERMINAL_RIGHT_RECT_HEIGHT + 20; // Aumento altezza

          // Area cliccabile per il terminale SINISTRO
          // Considera il pivot e aggiungi un margine per una migliore interazione
          const clickableLeftTerminalX = TERMINAL_LEFT_PIVOT_X - 10; // Sposta leggermente a sinistra del pivot
          const clickableLeftTerminalY = TERMINAL_LEFT_PIVOT_Y - (TERMINAL_LEFT_RECT_HEIGHT / 2) - 10;
          const clickableLeftTerminalWidth = TERMINAL_LEFT_RECT_WIDTH + 15; // Aumento larghezza
          const clickableLeftTerminalHeight = TERMINAL_LEFT_RECT_HEIGHT + 20; // Aumento altezza


          // Gestione click terminale DESTRO
          if (mouseXScaled > clickableRightTerminalX && mouseXScaled < clickableRightTerminalX + clickableRightTerminalWidth &&
              mouseYScaled > clickableRightTerminalY && mouseYScaled < clickableRightTerminalY + clickableRightTerminalHeight) {
            isRightCircuitOn = !isRightCircuitOn;

            if (isRightCircuitOn) {
              rightTerminalTargetAngle = RIGHT_TERMINAL_ON_ANGLE;
            } else {
              rightTerminalTargetAngle = RIGHT_TERMINAL_OFF_ANGLE;
            }
          }

          // Gestione click terminale SINISTRO
          else if (mouseXScaled > clickableLeftTerminalX && mouseXScaled < clickableLeftTerminalX + clickableLeftTerminalWidth &&
                   mouseYScaled > clickableLeftTerminalY && mouseYScaled < clickableLeftTerminalY + clickableLeftTerminalHeight) {
            isLeftCircuitOn = !isLeftCircuitOn;

            if (isLeftCircuitOn) {
              leftTerminalTargetAngle = LEFT_TERMINAL_ON_ANGLE;
            } else {
              leftTerminalTargetAngle = LEFT_TERMINAL_OFF_ANGLE;
            }
          }
        }

        // --- Funzioni per disegnare i singoli componenti ---

        // Questa funzione disegna i rami controllati dallo stato del terminale DESTRO
        function drawMainCircuitLines_RightControlled(activeStrokeColor) {
          noFill();
          strokeWeight(1);
          strokeJoin(MITER);

          // Ramo 2: Ramo superiore destro del circuito (controllato dal terminale DESTRO)
          stroke(activeStrokeColor);
          beginShape();
          vertex(248, 102);
          vertex(308, 102);
          vertex(313, 97);
          vertex(313, 24);
          vertex(318, 20);
          vertex(327, 20);
          endShape();

          // Ramo 5: Ramo destro generale del circuito (ramo laterale con zig-zag) (controllato dal terminale DESTRO)
          stroke(activeStrokeColor);
          beginShape();
          vertex(355, 20);
          vertex(363, 20);
          vertex(368, 25);
          vertex(368, 107);
          vertex(363, 111);
          vertex(38, 111);
          vertex(33, 106);
          vertex(33, 53);
          vertex(22, 35);
          vertex(50, 35);
          vertex(40, 53);
          vertex(40, 96);
          vertex(45, 101);
          vertex(100, 101);
          endShape();
        }

        // Questa funzione disegna i rami controllati dallo stato del terminale SINISTRO
        function drawMainCircuitLines_LeftControlled(activeStrokeColor) {
          noFill();
          strokeWeight(1);
          strokeJoin(MITER);

          // Ramo 3: Ramo centrale sinistro del circuito (con zig-zag) (controllato dal terminale SINISTRO)
          stroke(activeStrokeColor);
          beginShape();
          vertex(138, 20);
          vertex(147, 20);
          vertex(151, 25);
          vertex(151, 87);
          vertex(156, 92);
          vertex(235, 92);
          vertex(239, 87);
          vertex(239, 52);
          vertex(228, 34);
          vertex(258, 34);
          vertex(246, 52);
          vertex(246, 100);
          endShape();

          // Ramo 4: Ramo sinistro generale del circuito (ramo laterale) (controllato dal terminale SINISTRO)
          stroke(activeStrokeColor);
          beginShape();
          vertex(98, 100);
          vertex(97, 97);
          vertex(97, 24);
          vertex(101, 20);
          vertex(110, 20);
          endShape();
        }

        // Funzione per disegnare il ramo comune (Ramo 1)
        function drawMainCircuitLines_Common(activeStrokeColor) {
          noFill();
          strokeWeight(1);
          strokeJoin(MITER);

          // Ramo 1: Linea orizzontale centrale (ora usa la logica XOR)
          stroke(activeStrokeColor);
          line(97, 101, 248, 101);
        }


        function drawRightBlock(baseX, baseY) {
          noStroke();
          fill(GREEN_CIRCUIT);

          rect(baseX + 10, baseY, 7, 5);
          rect(baseX, baseY + 4, 27, 42);

          fill(WHITE_COMPONENT);
          push();
          translate(baseX + 16.5, baseY + 13);
          rotate(radians(90));
          rect(0, 0, 1, 6, 1);
          pop();

          push();
          translate(baseX + 14, baseY + 10.5);
          rotate(radians(90));
          rect(0, 0, 6, 1, 1);
          pop();

          push();
          translate(baseX + 16.5, baseY + 33);
          rotate(radians(90));
          rect(0, 0, 1, 6, 1);
          pop();
        }

        function drawLeftBlock(baseX, baseY) {
          noStroke();
          fill(GREEN_CIRCUIT);

          rect(baseX + 10, baseY, 7, 5);
          rect(baseX, baseY + 4, 27, 42);

          fill(WHITE_COMPONENT);
          push();
          translate(baseX + 16.5, baseY + 13);
          rotate(radians(90));
          rect(0, 0, 1, 6, 1);
          pop();

          push();
          translate(baseX + 14, baseY + 10.5);
          rotate(radians(90));
          rect(0, 0, 6, 1, 1);
          pop();

          push();
          translate(baseX + 16.5, baseY + 33);
          rotate(radians(90));
          rect(0, 0, 1, 6, 1);
          pop();
        }

        function drawRightDial(baseX, baseY) {
          noStroke();
          fill(DARK_BLUE_KNOB);

          rect(baseX + 1.6, baseY - 4, 18, 5, 2);
          rect(baseX - 3, baseY + 2, 28, 5, 2);
          rect(baseX - 3, baseY + 8, 28, 5, 2);

          fill(MEDIUM_BLUE_KNOB);
          rect(baseX + 2, baseY + 15, 17, 3, 2);
        }

        function drawLeftDial(baseX, baseY) {
          noStroke();
          fill(DARK_BLUE_KNOB);

          rect(baseX + 9.4, baseY - 7, 18, 5, 2);
          rect(baseX + 4, baseY - 1, 28, 5, 2);
          rect(baseX + 4, baseY + 5, 28, 5, 2);

          fill(MEDIUM_BLUE_KNOB);
          rect(baseX + 9.4, baseY + 12, 17, 3, 2);
        }

        function drawRightLightbulb(centerX, centerY, currentAlpha) {
          push();
          let yellowWithAlpha = color(red(YELLOW_LIGHT), green(YELLOW_LIGHT), blue(YELLOW_LIGHT), currentAlpha);
          let whiteWithAlpha = color(red(WHITE_COMPONENT), green(WHITE_COMPONENT), blue(WHITE_COMPONENT), currentAlpha);
          noStroke();

          fill(yellowWithAlpha);
          ellipse(centerX, centerY, 50, 50);

          fill(whiteWithAlpha);
          ellipse(centerX - 15, centerY - 12, 10, 10);
          pop();
        }

        function drawLeftLightbulb(centerX, centerY, currentAlpha) {
          push();
          let yellowWithAlpha = color(red(YELLOW_LIGHT), green(YELLOW_LIGHT), blue(YELLOW_LIGHT), currentAlpha);
          let whiteWithAlpha = color(red(WHITE_COMPONENT), green(WHITE_COMPONENT), blue(WHITE_COMPONENT), currentAlpha);
          noStroke();

          fill(yellowWithAlpha);
          ellipse(centerX, centerY, 50, 50);

          fill(whiteWithAlpha);
          ellipse(centerX - 15, centerY - 12, 10, 10);
          pop();
        }

        function drawTerminalsAndTopGreenElements(rightTerminalAngle, rightActiveColor, leftTerminalAngle, leftActiveColor) {
          noStroke();

          // --- Cerchi dei terminali (in alto) ---
          // Cerchi destri (cambiano colore in base a rightActiveColor)
          fill(rightActiveColor);
          circle(325, 20, 7); // Cerchio destro interno
          circle(355, 20, 7); // Cerchio destro esterno

          // Cerchi sinistri (cambiano colore in base a leftActiveColor)
          fill(leftActiveColor);
          circle(109, 20, 7); // Cerchio sinistro interno
          circle(138, 20, 7); // Cerchio sinistro esterno

          // --- Terminale destro (rettangolo verde inclinato, animato) ---
          fill(rightActiveColor); // Anche il rettangolo cambia colore in base a rightActiveColor
          push();
          translate(TERMINAL_RIGHT_PIVOT_X, TERMINAL_RIGHT_PIVOT_Y);
          rotate(radians(rightTerminalAngle));
          rect(0, 0, TERMINAL_RIGHT_RECT_WIDTH, TERMINAL_RIGHT_RECT_HEIGHT, 1);
          pop();

          // --- Terminale sinistro (rettangolo verde inclinato, ora animato) ---
          fill(leftActiveColor); // Questo cambia colore in base a leftActiveColor
          push();
          translate(TERMINAL_LEFT_PIVOT_X, TERMINAL_LEFT_PIVOT_Y); // Usa il pivot specifico per il sinistro
          rotate(radians(leftTerminalAngle)); // Usa l'angolo del terminale sinistro
          rect(0, 0, TERMINAL_LEFT_RECT_WIDTH, TERMINAL_LEFT_RECT_HEIGHT, 1);
          pop();

          // --- Cerchi dei terminali (vicino alla linea orizzontale centrale) ---
          // Cerchio centrale sinistro (cambia colore in base a leftActiveColor)
          fill(leftActiveColor);
          circle(97, 100, 9);
          // Cerchio centrale destro (cambia colore in base a rightActiveColor)
          fill(rightActiveColor);
          circle(247, 100, 9);
        }
    </script>
</body>
</html>